# coding: utf-8

"""
    SevOne API Documentation

    Supported endpoints by the new RESTful API  # noqa: E501

    OpenAPI spec version: 2.1.18, Hash: db562e6
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class NetFlowApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_filter(self, dto, **kwargs):  # noqa: E501
        """Create Netflow filters  # noqa: E501

        Create a netflow filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_filter(dto, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NetFlowFilterCreateDto dto: dto (required)
        :return: NetFlowFilterDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_filter_with_http_info(dto, **kwargs)  # noqa: E501
        else:
            (data) = self.create_filter_with_http_info(dto, **kwargs)  # noqa: E501
            return data

    def create_filter_with_http_info(self, dto, **kwargs):  # noqa: E501
        """Create Netflow filters  # noqa: E501

        Create a netflow filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_filter_with_http_info(dto, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NetFlowFilterCreateDto dto: dto (required)
        :return: NetFlowFilterDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dto']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_filter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dto' is set
        if ('dto' not in params or
                params['dto'] is None):
            raise ValueError("Missing the required parameter `dto` when calling `create_filter`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dto' in params:
            body_params = params['dto']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/filters', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetFlowFilterDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_filter_entities(self, dto, id, **kwargs):  # noqa: E501
        """Create Netflow filters rules  # noqa: E501

        Create a netflow filter rules  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_filter_entities(dto, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NetFlowFilterEntityCreateDto dto: dto (required)
        :param int id: Filter Id (required)
        :return: NetFlowFilterEntityDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_filter_entities_with_http_info(dto, id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_filter_entities_with_http_info(dto, id, **kwargs)  # noqa: E501
            return data

    def create_filter_entities_with_http_info(self, dto, id, **kwargs):  # noqa: E501
        """Create Netflow filters rules  # noqa: E501

        Create a netflow filter rules  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_filter_entities_with_http_info(dto, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NetFlowFilterEntityCreateDto dto: dto (required)
        :param int id: Filter Id (required)
        :return: NetFlowFilterEntityDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dto', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_filter_entities" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dto' is set
        if ('dto' not in params or
                params['dto'] is None):
            raise ValueError("Missing the required parameter `dto` when calling `create_filter_entities`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `create_filter_entities`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dto' in params:
            body_params = params['dto']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/filters/{id}/rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetFlowFilterEntityDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_mappings(self, new_object_mapping, **kwargs):  # noqa: E501
        """Create object mapping  # noqa: E501

        Create object mapping  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_mappings(new_object_mapping, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FlowDeviceMappingDto new_object_mapping: newObjectMapping (required)
        :return: FlowDeviceMappingDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_mappings_with_http_info(new_object_mapping, **kwargs)  # noqa: E501
        else:
            (data) = self.create_mappings_with_http_info(new_object_mapping, **kwargs)  # noqa: E501
            return data

    def create_mappings_with_http_info(self, new_object_mapping, **kwargs):  # noqa: E501
        """Create object mapping  # noqa: E501

        Create object mapping  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_mappings_with_http_info(new_object_mapping, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FlowDeviceMappingDto new_object_mapping: newObjectMapping (required)
        :return: FlowDeviceMappingDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['new_object_mapping']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_mappings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'new_object_mapping' is set
        if ('new_object_mapping' not in params or
                params['new_object_mapping'] is None):
            raise ValueError("Missing the required parameter `new_object_mapping` when calling `create_mappings`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'new_object_mapping' in params:
            body_params = params['new_object_mapping']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/objectMappings', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FlowDeviceMappingDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_subnet(self, dto, id, **kwargs):  # noqa: E501
        """Create subnet  # noqa: E501

        Create a subnet  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_subnet(dto, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NetFlowSubnetCreateDto dto: dto (required)
        :param int id: Segment Id (required)
        :return: NetFlowSubnetDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_subnet_with_http_info(dto, id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_subnet_with_http_info(dto, id, **kwargs)  # noqa: E501
            return data

    def create_subnet_with_http_info(self, dto, id, **kwargs):  # noqa: E501
        """Create subnet  # noqa: E501

        Create a subnet  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_subnet_with_http_info(dto, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NetFlowSubnetCreateDto dto: dto (required)
        :param int id: Segment Id (required)
        :return: NetFlowSubnetDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dto', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_subnet" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dto' is set
        if ('dto' not in params or
                params['dto'] is None):
            raise ValueError("Missing the required parameter `dto` when calling `create_subnet`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `create_subnet`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dto' in params:
            body_params = params['dto']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/segments/{id}/subnets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetFlowSubnetDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_subnet_category(self, dto, **kwargs):  # noqa: E501
        """Create Network Segment  # noqa: E501

        Create a Network Segment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_subnet_category(dto, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NetFlowSubnetCategoryCreateDto dto: dto (required)
        :return: NetFlowSubnetCategoryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_subnet_category_with_http_info(dto, **kwargs)  # noqa: E501
        else:
            (data) = self.create_subnet_category_with_http_info(dto, **kwargs)  # noqa: E501
            return data

    def create_subnet_category_with_http_info(self, dto, **kwargs):  # noqa: E501
        """Create Network Segment  # noqa: E501

        Create a Network Segment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_subnet_category_with_http_info(dto, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NetFlowSubnetCategoryCreateDto dto: dto (required)
        :return: NetFlowSubnetCategoryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dto']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_subnet_category" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dto' is set
        if ('dto' not in params or
                params['dto'] is None):
            raise ValueError("Missing the required parameter `dto` when calling `create_subnet_category`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dto' in params:
            body_params = params['dto']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/segments', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetFlowSubnetCategoryDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delet_subnet_by_id(self, id, **kwargs):  # noqa: E501
        """Delete subnet  # noqa: E501

        Deletes an existing subnet  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delet_subnet_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The id of the subnet to be deleted (required)
        :return: ResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delet_subnet_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delet_subnet_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delet_subnet_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete subnet  # noqa: E501

        Deletes an existing subnet  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delet_subnet_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The id of the subnet to be deleted (required)
        :return: ResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delet_subnet_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delet_subnet_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/segments/subnets/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResponseEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delet_subnet_category_by_id(self, id, **kwargs):  # noqa: E501
        """Delete Network Segment  # noqa: E501

        Deletes an existing Network Segment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delet_subnet_category_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The id of the segment to be deleted (required)
        :return: ResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delet_subnet_category_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delet_subnet_category_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delet_subnet_category_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete Network Segment  # noqa: E501

        Deletes an existing Network Segment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delet_subnet_category_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The id of the segment to be deleted (required)
        :return: ResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delet_subnet_category_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delet_subnet_category_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/segments/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResponseEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_filter(self, id, **kwargs):  # noqa: E501
        """Delete Netflow filter  # noqa: E501

        Deletes an existing netflow filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_filter(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The id of the filter to be deleted (required)
        :return: ResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_filter_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_filter_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_filter_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete Netflow filter  # noqa: E501

        Deletes an existing netflow filter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_filter_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The id of the filter to be deleted (required)
        :return: ResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_filter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_filter`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/filters/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResponseEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_filter_entity(self, id, rule_id, **kwargs):  # noqa: E501
        """Delete Netflow filter rule  # noqa: E501

        Deletes an existing netflow filter rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_filter_entity(id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The id of the filter that has the rule (required)
        :param int rule_id: The id of the filter rule to be deleted (required)
        :return: ResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_filter_entity_with_http_info(id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_filter_entity_with_http_info(id, rule_id, **kwargs)  # noqa: E501
            return data

    def delete_filter_entity_with_http_info(self, id, rule_id, **kwargs):  # noqa: E501
        """Delete Netflow filter rule  # noqa: E501

        Deletes an existing netflow filter rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_filter_entity_with_http_info(id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The id of the filter that has the rule (required)
        :param int rule_id: The id of the filter rule to be deleted (required)
        :return: ResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'rule_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_filter_entity" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_filter_entity`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `delete_filter_entity`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'rule_id' in params:
            path_params['ruleId'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/filters/{id}/rules/{ruleId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResponseEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_object_mapping_by_id(self, id, **kwargs):  # noqa: E501
        """Delete Object Mapping by Id  # noqa: E501

        Deletes an existing Object mapping   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_object_mapping_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The id of the the object mapping to be deleted (required)
        :return: ResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_object_mapping_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_object_mapping_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_object_mapping_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete Object Mapping by Id  # noqa: E501

        Deletes an existing Object mapping   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_object_mapping_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The id of the the object mapping to be deleted (required)
        :return: ResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_object_mapping_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_object_mapping_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/objectMappings/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResponseEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def filter_net_flow_device_interfaces(self, filter, **kwargs):  # noqa: E501
        """Get NetFlow device interfaces  # noqa: E501

        Endpoint for retrieving all NetFlow device interfaces that match the criteria  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.filter_net_flow_device_interfaces(filter, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NetFlowInterfaceFilterDto filter: Netflow Device object that will be used for filtering (required)
        :param int page: The number of the requested page, defaults to 0
        :param int size: The size of the requested page, defaults to 20; limited to a configurable maximum (10000 by default)
        :param bool include_count: Whether to query for total elements count; defaults to true, set to false for performance boost
        :param str sort_by: String array of format \"parameter, -parameter, natural\\*parameter, -natural\\*parameter\", where minus is for descending, natural* is for natural sort
        :param str fields: String array of format \"id,name,objects(id,pluginId)\"; Defines which fields are returned 
        :return: PagerNetFlowInterfaceDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.filter_net_flow_device_interfaces_with_http_info(filter, **kwargs)  # noqa: E501
        else:
            (data) = self.filter_net_flow_device_interfaces_with_http_info(filter, **kwargs)  # noqa: E501
            return data

    def filter_net_flow_device_interfaces_with_http_info(self, filter, **kwargs):  # noqa: E501
        """Get NetFlow device interfaces  # noqa: E501

        Endpoint for retrieving all NetFlow device interfaces that match the criteria  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.filter_net_flow_device_interfaces_with_http_info(filter, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NetFlowInterfaceFilterDto filter: Netflow Device object that will be used for filtering (required)
        :param int page: The number of the requested page, defaults to 0
        :param int size: The size of the requested page, defaults to 20; limited to a configurable maximum (10000 by default)
        :param bool include_count: Whether to query for total elements count; defaults to true, set to false for performance boost
        :param str sort_by: String array of format \"parameter, -parameter, natural\\*parameter, -natural\\*parameter\", where minus is for descending, natural* is for natural sort
        :param str fields: String array of format \"id,name,objects(id,pluginId)\"; Defines which fields are returned 
        :return: PagerNetFlowInterfaceDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter', 'page', 'size', 'include_count', 'sort_by', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method filter_net_flow_device_interfaces" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'filter' is set
        if ('filter' not in params or
                params['filter'] is None):
            raise ValueError("Missing the required parameter `filter` when calling `filter_net_flow_device_interfaces`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'include_count' in params:
            query_params.append(('includeCount', params['include_count']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sortBy', params['sort_by']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'filter' in params:
            body_params = params['filter']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/devices/interfaces/filter', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagerNetFlowInterfaceDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def filter_net_flow_devices(self, filter, **kwargs):  # noqa: E501
        """Get all NetFlow devices  # noqa: E501

        Endpoint for retrieving all NetFlow devices that match the criteria  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.filter_net_flow_devices(filter, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NetFlowDeviceFilterDto filter: Netflow Device object that will be used for filtering (required)
        :param int page: The number of the requested page, defaults to 0
        :param int size: The size of the requested page, defaults to 20; limited to a configurable maximum (10000 by default)
        :param bool include_count: Whether to query for total elements count; defaults to true, set to false for performance boost
        :param str sort_by: String array of format \"parameter, -parameter, natural\\*parameter, -natural\\*parameter\", where minus is for descending, natural* is for natural sort
        :param str fields: String array of format \"id,name,objects(id,pluginId)\"; Defines which fields are returned 
        :return: PagerNetFlowDeviceDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.filter_net_flow_devices_with_http_info(filter, **kwargs)  # noqa: E501
        else:
            (data) = self.filter_net_flow_devices_with_http_info(filter, **kwargs)  # noqa: E501
            return data

    def filter_net_flow_devices_with_http_info(self, filter, **kwargs):  # noqa: E501
        """Get all NetFlow devices  # noqa: E501

        Endpoint for retrieving all NetFlow devices that match the criteria  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.filter_net_flow_devices_with_http_info(filter, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NetFlowDeviceFilterDto filter: Netflow Device object that will be used for filtering (required)
        :param int page: The number of the requested page, defaults to 0
        :param int size: The size of the requested page, defaults to 20; limited to a configurable maximum (10000 by default)
        :param bool include_count: Whether to query for total elements count; defaults to true, set to false for performance boost
        :param str sort_by: String array of format \"parameter, -parameter, natural\\*parameter, -natural\\*parameter\", where minus is for descending, natural* is for natural sort
        :param str fields: String array of format \"id,name,objects(id,pluginId)\"; Defines which fields are returned 
        :return: PagerNetFlowDeviceDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter', 'page', 'size', 'include_count', 'sort_by', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method filter_net_flow_devices" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'filter' is set
        if ('filter' not in params or
                params['filter'] is None):
            raise ValueError("Missing the required parameter `filter` when calling `filter_net_flow_devices`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'include_count' in params:
            query_params.append(('includeCount', params['include_count']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sortBy', params['sort_by']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'filter' in params:
            body_params = params['filter']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/devices/filter', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagerNetFlowDeviceDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def filter_netflow_fields(self, net_flow_field_filter_dto, **kwargs):  # noqa: E501
        """Filter netflow fields  # noqa: E501

        Filter netflow fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.filter_netflow_fields(net_flow_field_filter_dto, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NetFlowFieldFilterDto net_flow_field_filter_dto: Netflow Fileds filtering params (required)
        :param int page: The number of the requested page, defaults to 0
        :param int size: The size of the requested page, defaults to 20; limited to a configurable maximum (10000 by default)
        :param bool include_count: Whether to query for total elements count; defaults to true, set to false for performance boost
        :param str sort_by: String array of format \"parameter, -parameter, natural\\*parameter, -natural\\*parameter\", where minus is for descending, natural* is for natural sort
        :param str fields: String array of format \"id,name,objects(id,pluginId)\"; Defines which fields are returned 
        :return: PagerNetFlowFieldDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.filter_netflow_fields_with_http_info(net_flow_field_filter_dto, **kwargs)  # noqa: E501
        else:
            (data) = self.filter_netflow_fields_with_http_info(net_flow_field_filter_dto, **kwargs)  # noqa: E501
            return data

    def filter_netflow_fields_with_http_info(self, net_flow_field_filter_dto, **kwargs):  # noqa: E501
        """Filter netflow fields  # noqa: E501

        Filter netflow fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.filter_netflow_fields_with_http_info(net_flow_field_filter_dto, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NetFlowFieldFilterDto net_flow_field_filter_dto: Netflow Fileds filtering params (required)
        :param int page: The number of the requested page, defaults to 0
        :param int size: The size of the requested page, defaults to 20; limited to a configurable maximum (10000 by default)
        :param bool include_count: Whether to query for total elements count; defaults to true, set to false for performance boost
        :param str sort_by: String array of format \"parameter, -parameter, natural\\*parameter, -natural\\*parameter\", where minus is for descending, natural* is for natural sort
        :param str fields: String array of format \"id,name,objects(id,pluginId)\"; Defines which fields are returned 
        :return: PagerNetFlowFieldDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['net_flow_field_filter_dto', 'page', 'size', 'include_count', 'sort_by', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method filter_netflow_fields" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'net_flow_field_filter_dto' is set
        if ('net_flow_field_filter_dto' not in params or
                params['net_flow_field_filter_dto'] is None):
            raise ValueError("Missing the required parameter `net_flow_field_filter_dto` when calling `filter_netflow_fields`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'include_count' in params:
            query_params.append(('includeCount', params['include_count']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sortBy', params['sort_by']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'net_flow_field_filter_dto' in params:
            body_params = params['net_flow_field_filter_dto']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/fields/filter', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagerNetFlowFieldDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def filter_netflow_views(self, net_flow_view_filter_dto, **kwargs):  # noqa: E501
        """Filter views  # noqa: E501

        Filter netflow views  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.filter_netflow_views(net_flow_view_filter_dto, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NetFlowViewFilterDto net_flow_view_filter_dto: Netflow View filtering params (required)
        :param int page: The number of the requested page, defaults to 0
        :param int size: The size of the requested page, defaults to 20; limited to a configurable maximum (10000 by default)
        :param bool include_count: Whether to query for total elements count; defaults to true, set to false for performance boost
        :param str sort_by: String array of format \"parameter, -parameter, natural\\*parameter, -natural\\*parameter\", where minus is for descending, natural* is for natural sort
        :param str fields: String array of format \"id,name,objects(id,pluginId)\"; Defines which fields are returned 
        :return: PagerNetFlowAggregationTemplateDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.filter_netflow_views_with_http_info(net_flow_view_filter_dto, **kwargs)  # noqa: E501
        else:
            (data) = self.filter_netflow_views_with_http_info(net_flow_view_filter_dto, **kwargs)  # noqa: E501
            return data

    def filter_netflow_views_with_http_info(self, net_flow_view_filter_dto, **kwargs):  # noqa: E501
        """Filter views  # noqa: E501

        Filter netflow views  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.filter_netflow_views_with_http_info(net_flow_view_filter_dto, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NetFlowViewFilterDto net_flow_view_filter_dto: Netflow View filtering params (required)
        :param int page: The number of the requested page, defaults to 0
        :param int size: The size of the requested page, defaults to 20; limited to a configurable maximum (10000 by default)
        :param bool include_count: Whether to query for total elements count; defaults to true, set to false for performance boost
        :param str sort_by: String array of format \"parameter, -parameter, natural\\*parameter, -natural\\*parameter\", where minus is for descending, natural* is for natural sort
        :param str fields: String array of format \"id,name,objects(id,pluginId)\"; Defines which fields are returned 
        :return: PagerNetFlowAggregationTemplateDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['net_flow_view_filter_dto', 'page', 'size', 'include_count', 'sort_by', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method filter_netflow_views" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'net_flow_view_filter_dto' is set
        if ('net_flow_view_filter_dto' not in params or
                params['net_flow_view_filter_dto'] is None):
            raise ValueError("Missing the required parameter `net_flow_view_filter_dto` when calling `filter_netflow_views`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'include_count' in params:
            query_params.append(('includeCount', params['include_count']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sortBy', params['sort_by']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'net_flow_view_filter_dto' in params:
            body_params = params['net_flow_view_filter_dto']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/views/filter', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagerNetFlowAggregationTemplateDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def filter_view_indicators(self, view_id, net_flow_field_filter_dto, **kwargs):  # noqa: E501
        """Filter netflow view fields  # noqa: E501

        Filter netflow view fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.filter_view_indicators(view_id, net_flow_field_filter_dto, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int view_id: viewId (required)
        :param NetFlowFieldFilterDto net_flow_field_filter_dto: Netflow view fileds filtering params (required)
        :param int page: The number of the requested page, defaults to 0
        :param int size: The size of the requested page, defaults to 20; limited to a configurable maximum (10000 by default)
        :param bool include_count: Whether to query for total elements count; defaults to true, set to false for performance boost
        :param str sort_by: String array of format \"parameter, -parameter, natural\\*parameter, -natural\\*parameter\", where minus is for descending, natural* is for natural sort
        :param str fields: String array of format \"id,name,objects(id,pluginId)\"; Defines which fields are returned 
        :return: PagerNetFlowFieldDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.filter_view_indicators_with_http_info(view_id, net_flow_field_filter_dto, **kwargs)  # noqa: E501
        else:
            (data) = self.filter_view_indicators_with_http_info(view_id, net_flow_field_filter_dto, **kwargs)  # noqa: E501
            return data

    def filter_view_indicators_with_http_info(self, view_id, net_flow_field_filter_dto, **kwargs):  # noqa: E501
        """Filter netflow view fields  # noqa: E501

        Filter netflow view fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.filter_view_indicators_with_http_info(view_id, net_flow_field_filter_dto, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int view_id: viewId (required)
        :param NetFlowFieldFilterDto net_flow_field_filter_dto: Netflow view fileds filtering params (required)
        :param int page: The number of the requested page, defaults to 0
        :param int size: The size of the requested page, defaults to 20; limited to a configurable maximum (10000 by default)
        :param bool include_count: Whether to query for total elements count; defaults to true, set to false for performance boost
        :param str sort_by: String array of format \"parameter, -parameter, natural\\*parameter, -natural\\*parameter\", where minus is for descending, natural* is for natural sort
        :param str fields: String array of format \"id,name,objects(id,pluginId)\"; Defines which fields are returned 
        :return: PagerNetFlowFieldDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['view_id', 'net_flow_field_filter_dto', 'page', 'size', 'include_count', 'sort_by', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method filter_view_indicators" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'view_id' is set
        if ('view_id' not in params or
                params['view_id'] is None):
            raise ValueError("Missing the required parameter `view_id` when calling `filter_view_indicators`")  # noqa: E501
        # verify the required parameter 'net_flow_field_filter_dto' is set
        if ('net_flow_field_filter_dto' not in params or
                params['net_flow_field_filter_dto'] is None):
            raise ValueError("Missing the required parameter `net_flow_field_filter_dto` when calling `filter_view_indicators`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'view_id' in params:
            path_params['viewId'] = params['view_id']  # noqa: E501

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'include_count' in params:
            query_params.append(('includeCount', params['include_count']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sortBy', params['sort_by']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'net_flow_field_filter_dto' in params:
            body_params = params['net_flow_field_filter_dto']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/views/{viewId}/fields/filter', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagerNetFlowFieldDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_directions(self, netflow_device_id, interface_id, **kwargs):  # noqa: E501
        """Get directions by NetFlow device id and interface id  # noqa: E501

        Get directions by NetFlow device id and interface id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_directions(netflow_device_id, interface_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int netflow_device_id: netflowDeviceId (required)
        :param int interface_id: interfaceId (required)
        :return: list[NetFlowDirectionDto]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_directions_with_http_info(netflow_device_id, interface_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_directions_with_http_info(netflow_device_id, interface_id, **kwargs)  # noqa: E501
            return data

    def get_directions_with_http_info(self, netflow_device_id, interface_id, **kwargs):  # noqa: E501
        """Get directions by NetFlow device id and interface id  # noqa: E501

        Get directions by NetFlow device id and interface id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_directions_with_http_info(netflow_device_id, interface_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int netflow_device_id: netflowDeviceId (required)
        :param int interface_id: interfaceId (required)
        :return: list[NetFlowDirectionDto]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['netflow_device_id', 'interface_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_directions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'netflow_device_id' is set
        if ('netflow_device_id' not in params or
                params['netflow_device_id'] is None):
            raise ValueError("Missing the required parameter `netflow_device_id` when calling `get_directions`")  # noqa: E501
        # verify the required parameter 'interface_id' is set
        if ('interface_id' not in params or
                params['interface_id'] is None):
            raise ValueError("Missing the required parameter `interface_id` when calling `get_directions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'netflow_device_id' in params:
            path_params['netflowDeviceId'] = params['netflow_device_id']  # noqa: E501
        if 'interface_id' in params:
            path_params['interfaceId'] = params['interface_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/devices/{netflowDeviceId}/interfaces/{interfaceId}/directions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[NetFlowDirectionDto]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_filter_by_id(self, id, **kwargs):  # noqa: E501
        """Get Netflow filters  # noqa: E501

        Get filters  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_filter_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Filter Id (required)
        :return: list[NetFlowFilterDto]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_filter_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_filter_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_filter_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Netflow filters  # noqa: E501

        Get filters  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_filter_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Filter Id (required)
        :return: list[NetFlowFilterDto]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_filter_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_filter_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/filters/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[NetFlowFilterDto]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_filter_entities_by_id(self, id, **kwargs):  # noqa: E501
        """Get Netflow filter rules  # noqa: E501

        Get filters rules  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_filter_entities_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Filter Id (required)
        :return: list[NetFlowFilterEntityDto]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_filter_entities_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_filter_entities_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_filter_entities_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Netflow filter rules  # noqa: E501

        Get filters rules  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_filter_entities_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Filter Id (required)
        :return: list[NetFlowFilterEntityDto]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_filter_entities_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_filter_entities_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/filters/{id}/rules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[NetFlowFilterEntityDto]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_filters(self, **kwargs):  # noqa: E501
        """Get Netflow filters  # noqa: E501

        Get filters  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_filters(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[NetFlowFilterDto]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_filters_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_filters_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_filters_with_http_info(self, **kwargs):  # noqa: E501
        """Get Netflow filters  # noqa: E501

        Get filters  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_filters_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[NetFlowFilterDto]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_filters" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/filters', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[NetFlowFilterDto]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_interfaces(self, netflow_device_id, **kwargs):  # noqa: E501
        """Get interfaces by NetFlow device id  # noqa: E501

        Get interfaces by NetFlow device id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interfaces(netflow_device_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int netflow_device_id: netflowDeviceId (required)
        :return: list[NetFlowInterfaceDto]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_interfaces_with_http_info(netflow_device_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_interfaces_with_http_info(netflow_device_id, **kwargs)  # noqa: E501
            return data

    def get_interfaces_with_http_info(self, netflow_device_id, **kwargs):  # noqa: E501
        """Get interfaces by NetFlow device id  # noqa: E501

        Get interfaces by NetFlow device id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_interfaces_with_http_info(netflow_device_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int netflow_device_id: netflowDeviceId (required)
        :return: list[NetFlowInterfaceDto]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['netflow_device_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_interfaces" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'netflow_device_id' is set
        if ('netflow_device_id' not in params or
                params['netflow_device_id'] is None):
            raise ValueError("Missing the required parameter `netflow_device_id` when calling `get_interfaces`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'netflow_device_id' in params:
            path_params['netflowDeviceId'] = params['netflow_device_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/devices/{netflowDeviceId}/interfaces', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[NetFlowInterfaceDto]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_mapping_by_indicator(self, dtos, **kwargs):  # noqa: E501
        """Get flow interface to device indicator mapping by indicators  # noqa: E501

        Get flow interface to device indicator mapping by indicators  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mapping_by_indicator(dtos, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[DeviceIndicatorDto] dtos: dtos (required)
        :param int page: The number of the requested page, defaults to 0
        :param int size: The size of the requested page, defaults to 20; limited to a configurable maximum (10000 by default)
        :param bool include_count: Whether to query for total elements count; defaults to true, set to false for performance boost
        :param str sort_by: String array of format \"parameter, -parameter, natural\\*parameter, -natural\\*parameter\", where minus is for descending, natural* is for natural sort
        :param str fields: String array of format \"id,name,objects(id,pluginId)\"; Defines which fields are returned 
        :param bool include_automatic: Include automatic mappings
        :return: PagerFlowDeviceMappingDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_mapping_by_indicator_with_http_info(dtos, **kwargs)  # noqa: E501
        else:
            (data) = self.get_mapping_by_indicator_with_http_info(dtos, **kwargs)  # noqa: E501
            return data

    def get_mapping_by_indicator_with_http_info(self, dtos, **kwargs):  # noqa: E501
        """Get flow interface to device indicator mapping by indicators  # noqa: E501

        Get flow interface to device indicator mapping by indicators  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mapping_by_indicator_with_http_info(dtos, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[DeviceIndicatorDto] dtos: dtos (required)
        :param int page: The number of the requested page, defaults to 0
        :param int size: The size of the requested page, defaults to 20; limited to a configurable maximum (10000 by default)
        :param bool include_count: Whether to query for total elements count; defaults to true, set to false for performance boost
        :param str sort_by: String array of format \"parameter, -parameter, natural\\*parameter, -natural\\*parameter\", where minus is for descending, natural* is for natural sort
        :param str fields: String array of format \"id,name,objects(id,pluginId)\"; Defines which fields are returned 
        :param bool include_automatic: Include automatic mappings
        :return: PagerFlowDeviceMappingDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dtos', 'page', 'size', 'include_count', 'sort_by', 'fields', 'include_automatic']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_mapping_by_indicator" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dtos' is set
        if ('dtos' not in params or
                params['dtos'] is None):
            raise ValueError("Missing the required parameter `dtos` when calling `get_mapping_by_indicator`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'include_count' in params:
            query_params.append(('includeCount', params['include_count']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sortBy', params['sort_by']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'include_automatic' in params:
            query_params.append(('includeAutomatic', params['include_automatic']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dtos' in params:
            body_params = params['dtos']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/objectMappings/filterByIndicator', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagerFlowDeviceMappingDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_mapping_by_interfaces(self, dtos, **kwargs):  # noqa: E501
        """Get flow interface to device indicator mapping by interface  # noqa: E501

        Get flow interface to device indicator mapping by interfaces  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mapping_by_interfaces(dtos, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[FlowInterfaceDto] dtos: dtos (required)
        :param int page: The number of the requested page, defaults to 0
        :param int size: The size of the requested page, defaults to 20; limited to a configurable maximum (10000 by default)
        :param bool include_count: Whether to query for total elements count; defaults to true, set to false for performance boost
        :param str sort_by: String array of format \"parameter, -parameter, natural\\*parameter, -natural\\*parameter\", where minus is for descending, natural* is for natural sort
        :param str fields: String array of format \"id,name,objects(id,pluginId)\"; Defines which fields are returned 
        :param bool include_automatic: Include automatic mappings
        :return: PagerFlowDeviceMappingDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_mapping_by_interfaces_with_http_info(dtos, **kwargs)  # noqa: E501
        else:
            (data) = self.get_mapping_by_interfaces_with_http_info(dtos, **kwargs)  # noqa: E501
            return data

    def get_mapping_by_interfaces_with_http_info(self, dtos, **kwargs):  # noqa: E501
        """Get flow interface to device indicator mapping by interface  # noqa: E501

        Get flow interface to device indicator mapping by interfaces  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mapping_by_interfaces_with_http_info(dtos, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[FlowInterfaceDto] dtos: dtos (required)
        :param int page: The number of the requested page, defaults to 0
        :param int size: The size of the requested page, defaults to 20; limited to a configurable maximum (10000 by default)
        :param bool include_count: Whether to query for total elements count; defaults to true, set to false for performance boost
        :param str sort_by: String array of format \"parameter, -parameter, natural\\*parameter, -natural\\*parameter\", where minus is for descending, natural* is for natural sort
        :param str fields: String array of format \"id,name,objects(id,pluginId)\"; Defines which fields are returned 
        :param bool include_automatic: Include automatic mappings
        :return: PagerFlowDeviceMappingDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dtos', 'page', 'size', 'include_count', 'sort_by', 'fields', 'include_automatic']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_mapping_by_interfaces" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dtos' is set
        if ('dtos' not in params or
                params['dtos'] is None):
            raise ValueError("Missing the required parameter `dtos` when calling `get_mapping_by_interfaces`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'include_count' in params:
            query_params.append(('includeCount', params['include_count']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sortBy', params['sort_by']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'include_automatic' in params:
            query_params.append(('includeAutomatic', params['include_automatic']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dtos' in params:
            body_params = params['dtos']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/objectMappings/filterByInterface', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagerFlowDeviceMappingDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_mappings(self, **kwargs):  # noqa: E501
        """Get flow interface to device indicator mappings  # noqa: E501

        Get flow interface to device indicator mappings  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mappings(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: The number of the requested page, defaults to 0
        :param int size: The size of the requested page, defaults to 20; limited to a configurable maximum (10000 by default)
        :param bool include_count: Whether to query for total elements count; defaults to true, set to false for performance boost
        :param str sort_by: String array of format \"parameter, -parameter, natural\\*parameter, -natural\\*parameter\", where minus is for descending, natural* is for natural sort
        :param str fields: String array of format \"id,name,objects(id,pluginId)\"; Defines which fields are returned 
        :param bool include_automatic: Include automatic mappings
        :return: PagerFlowDeviceMappingDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_mappings_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_mappings_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_mappings_with_http_info(self, **kwargs):  # noqa: E501
        """Get flow interface to device indicator mappings  # noqa: E501

        Get flow interface to device indicator mappings  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mappings_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: The number of the requested page, defaults to 0
        :param int size: The size of the requested page, defaults to 20; limited to a configurable maximum (10000 by default)
        :param bool include_count: Whether to query for total elements count; defaults to true, set to false for performance boost
        :param str sort_by: String array of format \"parameter, -parameter, natural\\*parameter, -natural\\*parameter\", where minus is for descending, natural* is for natural sort
        :param str fields: String array of format \"id,name,objects(id,pluginId)\"; Defines which fields are returned 
        :param bool include_automatic: Include automatic mappings
        :return: PagerFlowDeviceMappingDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'include_count', 'sort_by', 'fields', 'include_automatic']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_mappings" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'include_count' in params:
            query_params.append(('includeCount', params['include_count']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sortBy', params['sort_by']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'include_automatic' in params:
            query_params.append(('includeAutomatic', params['include_automatic']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/objectMappings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagerFlowDeviceMappingDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_net_flow_devices(self, **kwargs):  # noqa: E501
        """Get all NetFlow devices  # noqa: E501

        Endpoint for retrieving all NetFlow devices with support for pagination  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_net_flow_devices(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: The number of the requested page, defaults to 0
        :param int size: The size of the requested page, defaults to 20; limited to a configurable maximum (10000 by default)
        :param bool include_count: Whether to query for total elements count; defaults to true, set to false for performance boost
        :param str sort_by: String array of format \"parameter, -parameter, natural\\*parameter, -natural\\*parameter\", where minus is for descending, natural* is for natural sort
        :param str fields: String array of format \"id,name,objects(id,pluginId)\"; Defines which fields are returned 
        :return: PagerNetFlowDeviceDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_net_flow_devices_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_net_flow_devices_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_net_flow_devices_with_http_info(self, **kwargs):  # noqa: E501
        """Get all NetFlow devices  # noqa: E501

        Endpoint for retrieving all NetFlow devices with support for pagination  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_net_flow_devices_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: The number of the requested page, defaults to 0
        :param int size: The size of the requested page, defaults to 20; limited to a configurable maximum (10000 by default)
        :param bool include_count: Whether to query for total elements count; defaults to true, set to false for performance boost
        :param str sort_by: String array of format \"parameter, -parameter, natural\\*parameter, -natural\\*parameter\", where minus is for descending, natural* is for natural sort
        :param str fields: String array of format \"id,name,objects(id,pluginId)\"; Defines which fields are returned 
        :return: PagerNetFlowDeviceDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'include_count', 'sort_by', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_net_flow_devices" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'include_count' in params:
            query_params.append(('includeCount', params['include_count']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sortBy', params['sort_by']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/devices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagerNetFlowDeviceDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_net_flow_modes(self, **kwargs):  # noqa: E501
        """Get the status of NetFlow settings  # noqa: E501

        Endpoint for retrieving the status of NetFlow settings  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_net_flow_modes(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: NetFlowModesDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_net_flow_modes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_net_flow_modes_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_net_flow_modes_with_http_info(self, **kwargs):  # noqa: E501
        """Get the status of NetFlow settings  # noqa: E501

        Endpoint for retrieving the status of NetFlow settings  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_net_flow_modes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: NetFlowModesDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_net_flow_modes" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/settings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetFlowModesDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_netflow_categories(self, **kwargs):  # noqa: E501
        """Get netflow view categories  # noqa: E501

        Get netflow view categories  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_netflow_categories(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: The number of the requested page, defaults to 0
        :param int size: The size of the requested page, defaults to 20; limited to a configurable maximum (10000 by default)
        :param bool include_count: Whether to query for total elements count; defaults to true, set to false for performance boost
        :param str sort_by: String array of format \"parameter, -parameter, natural\\*parameter, -natural\\*parameter\", where minus is for descending, natural* is for natural sort
        :param str fields: String array of format \"id,name,objects(id,pluginId)\"; Defines which fields are returned 
        :return: PagerNetFlowViewCategoryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_netflow_categories_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_netflow_categories_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_netflow_categories_with_http_info(self, **kwargs):  # noqa: E501
        """Get netflow view categories  # noqa: E501

        Get netflow view categories  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_netflow_categories_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: The number of the requested page, defaults to 0
        :param int size: The size of the requested page, defaults to 20; limited to a configurable maximum (10000 by default)
        :param bool include_count: Whether to query for total elements count; defaults to true, set to false for performance boost
        :param str sort_by: String array of format \"parameter, -parameter, natural\\*parameter, -natural\\*parameter\", where minus is for descending, natural* is for natural sort
        :param str fields: String array of format \"id,name,objects(id,pluginId)\"; Defines which fields are returned 
        :return: PagerNetFlowViewCategoryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'include_count', 'sort_by', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_netflow_categories" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'include_count' in params:
            query_params.append(('includeCount', params['include_count']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sortBy', params['sort_by']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/views/categories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagerNetFlowViewCategoryDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_netflow_fields(self, **kwargs):  # noqa: E501
        """Get netflow fields  # noqa: E501

        Get netflow fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_netflow_fields(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: The number of the requested page, defaults to 0
        :param int size: The size of the requested page, defaults to 20; limited to a configurable maximum (10000 by default)
        :param bool include_count: Whether to query for total elements count; defaults to true, set to false for performance boost
        :param str sort_by: String array of format \"parameter, -parameter, natural\\*parameter, -natural\\*parameter\", where minus is for descending, natural* is for natural sort
        :param str fields: String array of format \"id,name,objects(id,pluginId)\"; Defines which fields are returned 
        :return: PagerNetFlowFieldDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_netflow_fields_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_netflow_fields_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_netflow_fields_with_http_info(self, **kwargs):  # noqa: E501
        """Get netflow fields  # noqa: E501

        Get netflow fields  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_netflow_fields_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: The number of the requested page, defaults to 0
        :param int size: The size of the requested page, defaults to 20; limited to a configurable maximum (10000 by default)
        :param bool include_count: Whether to query for total elements count; defaults to true, set to false for performance boost
        :param str sort_by: String array of format \"parameter, -parameter, natural\\*parameter, -natural\\*parameter\", where minus is for descending, natural* is for natural sort
        :param str fields: String array of format \"id,name,objects(id,pluginId)\"; Defines which fields are returned 
        :return: PagerNetFlowFieldDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'include_count', 'sort_by', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_netflow_fields" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'include_count' in params:
            query_params.append(('includeCount', params['include_count']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sortBy', params['sort_by']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/fields', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagerNetFlowFieldDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_network_segments(self, **kwargs):  # noqa: E501
        """Get Network Segments  # noqa: E501

        Get Networks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_network_segments(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[NetFlowSubnetCategoryDto]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_network_segments_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_network_segments_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_network_segments_with_http_info(self, **kwargs):  # noqa: E501
        """Get Network Segments  # noqa: E501

        Get Networks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_network_segments_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[NetFlowSubnetCategoryDto]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_network_segments" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/segments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[NetFlowSubnetCategoryDto]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_protocols(self, **kwargs):  # noqa: E501
        """Get protocols  # noqa: E501

        Get protocols  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_protocols(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[NetFlowProtocolDto]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_protocols_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_protocols_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_protocols_with_http_info(self, **kwargs):  # noqa: E501
        """Get protocols  # noqa: E501

        Get protocols  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_protocols_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[NetFlowProtocolDto]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_protocols" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/protocols', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[NetFlowProtocolDto]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_report_columns_using_get(self, view_id, **kwargs):  # noqa: E501
        """getReportColumns  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_columns_using_get(view_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int view_id: viewId (required)
        :return: list[NetflowReportingColumnDto]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_report_columns_using_get_with_http_info(view_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_report_columns_using_get_with_http_info(view_id, **kwargs)  # noqa: E501
            return data

    def get_report_columns_using_get_with_http_info(self, view_id, **kwargs):  # noqa: E501
        """getReportColumns  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_columns_using_get_with_http_info(view_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int view_id: viewId (required)
        :return: list[NetflowReportingColumnDto]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['view_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_columns_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'view_id' is set
        if ('view_id' not in params or
                params['view_id'] is None):
            raise ValueError("Missing the required parameter `view_id` when calling `get_report_columns_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'view_id' in params:
            path_params['viewId'] = params['view_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/views/{viewId}/reportColumns', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[NetflowReportingColumnDto]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_services_by_port(self, **kwargs):  # noqa: E501
        """Get services by port  # noqa: E501

        Get applications by port  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_services_by_port(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[NetFlowApplicationDto]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_services_by_port_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_services_by_port_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_services_by_port_with_http_info(self, **kwargs):  # noqa: E501
        """Get services by port  # noqa: E501

        Get applications by port  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_services_by_port_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[NetFlowApplicationDto]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_services_by_port" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/services', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[NetFlowApplicationDto]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_subnet_category_by_id(self, id, **kwargs):  # noqa: E501
        """Get Network Segment By Id  # noqa: E501

        et Network Segment By Id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_subnet_category_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Segment Id (required)
        :return: NetFlowSubnetCategoryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_subnet_category_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subnet_category_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_subnet_category_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Network Segment By Id  # noqa: E501

        et Network Segment By Id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_subnet_category_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Segment Id (required)
        :return: NetFlowSubnetCategoryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subnet_category_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_subnet_category_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/segments/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetFlowSubnetCategoryDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_subnets(self, **kwargs):  # noqa: E501
        """Get subnets  # noqa: E501

        Get subnets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_subnets(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[NetFlowSubnetDto]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_subnets_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_subnets_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_subnets_with_http_info(self, **kwargs):  # noqa: E501
        """Get subnets  # noqa: E501

        Get subnets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_subnets_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[NetFlowSubnetDto]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subnets" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/segments/subnets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[NetFlowSubnetDto]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_subnets_by_category_id(self, id, **kwargs):  # noqa: E501
        """Get subnets  # noqa: E501

        Get subnets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_subnets_by_category_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Segment Id (required)
        :return: list[NetFlowSubnetDto]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_subnets_by_category_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subnets_by_category_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_subnets_by_category_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get subnets  # noqa: E501

        Get subnets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_subnets_by_category_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Segment Id (required)
        :return: list[NetFlowSubnetDto]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subnets_by_category_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_subnets_by_category_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/segments/{id}/subnets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[NetFlowSubnetDto]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_view_indicators(self, view_id, **kwargs):  # noqa: E501
        """Get the keys and metrics in a FlowFalcon view  # noqa: E501

        Endpoint for retrieving the keys and metrics in a FlowFalcon view  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_view_indicators(view_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int view_id: viewId (required)
        :param bool include_members: Include members, defaults to false
        :return: FlowFalconViewIndicatorsDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_view_indicators_with_http_info(view_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_view_indicators_with_http_info(view_id, **kwargs)  # noqa: E501
            return data

    def get_view_indicators_with_http_info(self, view_id, **kwargs):  # noqa: E501
        """Get the keys and metrics in a FlowFalcon view  # noqa: E501

        Endpoint for retrieving the keys and metrics in a FlowFalcon view  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_view_indicators_with_http_info(view_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int view_id: viewId (required)
        :param bool include_members: Include members, defaults to false
        :return: FlowFalconViewIndicatorsDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['view_id', 'include_members']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_view_indicators" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'view_id' is set
        if ('view_id' not in params or
                params['view_id'] is None):
            raise ValueError("Missing the required parameter `view_id` when calling `get_view_indicators`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'view_id' in params:
            path_params['viewId'] = params['view_id']  # noqa: E501

        query_params = []
        if 'include_members' in params:
            query_params.append(('includeMembers', params['include_members']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/views/{viewId}/fields', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FlowFalconViewIndicatorsDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_views(self, **kwargs):  # noqa: E501
        """Get views  # noqa: E501

        Get views  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_views(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: The number of the requested page, defaults to 0
        :param int size: The size of the requested page, defaults to 20; limited to a configurable maximum (10000 by default)
        :param bool include_count: Whether to query for total elements count; defaults to true, set to false for performance boost
        :param str sort_by: String array of format \"parameter, -parameter, natural\\*parameter, -natural\\*parameter\", where minus is for descending, natural* is for natural sort
        :param str fields: String array of format \"id,name,objects(id,pluginId)\"; Defines which fields are returned 
        :return: PagerNetFlowAggregationTemplateDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_views_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_views_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_views_with_http_info(self, **kwargs):  # noqa: E501
        """Get views  # noqa: E501

        Get views  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_views_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: The number of the requested page, defaults to 0
        :param int size: The size of the requested page, defaults to 20; limited to a configurable maximum (10000 by default)
        :param bool include_count: Whether to query for total elements count; defaults to true, set to false for performance boost
        :param str sort_by: String array of format \"parameter, -parameter, natural\\*parameter, -natural\\*parameter\", where minus is for descending, natural* is for natural sort
        :param str fields: String array of format \"id,name,objects(id,pluginId)\"; Defines which fields are returned 
        :return: PagerNetFlowAggregationTemplateDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'include_count', 'sort_by', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_views" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'include_count' in params:
            query_params.append(('includeCount', params['include_count']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sortBy', params['sort_by']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/netflow/views', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagerNetFlowAggregationTemplateDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
